(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["PlotPack`"]
myComplexListPlot::usage = "myComplexListPlot[v_List,xLabel_String,yLabel_String,opts___] Plots real and imaginary parts of \
a complex curve from a list v of the form:v={{x\_\(1\),y\_\(1\)},{x\_\(2\),y\_\(2\)}...}. It uses the built in function \
ListPlot. Standard graphics options can be included.  Note there is a new built in ComplexListPlot so changed name to \
myComplexListPlot"
ComplexListPointPlot::usage = "ComplexListPountPlot[v_List,xLabel_String,yLabel_String,opts___] Plots real and imaginary \
parts of a complex curve from a list v of the form:v={{x\_\(1\),y\_\(1\)},{x\_\(2\),y\_\(2\)}...}. It uses the built in \
function ListPlot. Same as ComplexListPlot but points are not joined"
ComplexVectorListPlot::usage = "ComplexVectorListPlot[v_List,xLabel_String,yLabel_String,opts___] Plots real and \
imaginary parts of a family of complex curves from a list v of the form: v= \
{{x1,y1[1],y1[2],...y1[N]},{x2,y2[1],y2[2],...y2[N]},...}.  It uses the  built-in function ListPlot.   Standard \
graphics options can be included"
VectorListPlot::usage = "ComplexVectorListPlot[v_List,xLabel_String,yLabel_String,opts___] Plots family of n curves \
from a list v of the form v= {{x1,y1[1],y1[2],...y1[N]},{x2,y2[1],y2[2],...y2[N]},...}. It uses the built-in function \
ListPlot. Standard graphics options can be included"
ZeroContourPlot::usage = "ZeroContourPlot[v_List,xRange_List,yRange_List,opts___] Plots the Re[v]=0 (->red) and Im[v]=0 \
(->blue)contours for  a rectangular MxN array of complex numbers,v.   Useful for finding the zeros of a function of a \
real variable z. The form of v is: {{v[x1,y1},v[x1,y2]...,v[x1,yN]},{v[x2,y1],v{x2,y2}....}, {v[xM,y1]....,v[xM,yN]}}.  \
 In other words y<->[imaginary part] varies most rapidly.   xRange and yRange are lists of the form: {xmin,xmax} for \
labeling the axes"
ComplexZeroContourPlot::usage = "ComplexZeroContourPlot[v_List,xRange_List,yRange_List,opts___] Plots the Re[v]=0 \
(->red) and Im[v]=0 (->blue)contours for  a rectangular MxN array of complex numbers,v.   Useful for finding the zeros \
of a function of a complex variable z. The form of v is: {{v[x1,y1},v[x1,y2]...,v[x1,yN]},{v[x2,y1],v{x2,y2}....}, \
{v[xM,y1]....,v[xM,yN]}}.   In other words y<->[imaginary part] varies most rapidly.   xRange and yRange are lists of \
the form: {xmin,xmax} for labeling the axes"
rootSort::usage = "rootSort[v_List] Sorts lists of form{{x1,roots1},{x2,roots2}....{xn,rootsn}} so as to try to \
maintain continuity of roots."
paramPrint::usage = "paramPrint[x_List] gives a convenient way of printing a list of parameters just by passing a list \
of the symbol names whose names and values are to be printed"
SetAttributes[PlotPack`paramPrint, HoldAll]; 
SetAttributes[PlotPack`paramPrintf, HoldAll]; 
SetAttributes[PlotPack`myPrint, HoldAll]; 
myPrint[x_] := Print[ToString[HoldForm[x]], "=", Evaluate[x]]; 
paramPrintf[x_List] := Thread[Hold[x], List]; 
paramPrint[x_List] := Apply[myPrint, paramPrintf[x], 1]; 
Begin["`Private`"]
myComplexListPlot[v_List, xLabel_String, yLabel_String, opts___] := 
  Module[{rev, imv}, rev = Re[Transpose[v][[2]]]; imv = Im[Transpose[v][[2]]]; 
    Show[ListPlot[Transpose[{Transpose[v][[1]], rev}], PlotJoined -> True, AxesLabel -> {xLabel, yLabel}, 
      PlotStyle -> Thickness[0.003], DisplayFunction -> Identity], ListPlot[Transpose[{Transpose[v][[1]], imv}], 
      PlotJoined -> True, DisplayFunction -> Identity, PlotStyle -> {Thickness[0.003], RGBColor[0, 0, 1], 
        Dashing[{0.05, 0.02}]}], opts, DisplayFunction -> $DisplayFunction]]
ComplexListPointPlot[v_List, xLabel_String, yLabel_String, opts___] := 
  Module[{rev, imv}, rev = Re[Transpose[v][[2]]]; imv = Im[Transpose[v][[2]]]; 
    Show[ListPlot[Transpose[{Transpose[v][[1]], rev}], PlotJoined -> False, AxesLabel -> {xLabel, yLabel}, 
      PlotStyle -> Thickness[0.003], DisplayFunction -> Identity], ListPlot[Transpose[{Transpose[v][[1]], imv}], 
      PlotJoined -> False, DisplayFunction -> Identity, PlotStyle -> {Thickness[0.003], RGBColor[0, 0, 1]}], opts, 
     DisplayFunction -> $DisplayFunction]]
ComplexVectorListPlot[v_List, xLabel_String, yLabel_String, opts___] := Module[{n, xv, yv, vt, nPts, color, g}, 
   n = Length[v[[1]]] - 1; vt = Transpose[v]; xv = vt[[1]]; nPts = Length[xv]; 
    color = {RGBColor[0, 0.8, 0], RGBColor[0, 0, 0], RGBColor[0, 0, 1], RGBColor[1, 0, 0], RGBColor[1., 0.4, 0.], 
      RGBColor[0.6, 0., 0.5]}; g = Table[i0 = Mod[i, 6] + 1; vr = Re[vt[[i + 1]]]; vi = Im[vt[[i + 1]]]; 
       {ListPlot[Transpose[{xv, vr}], PlotJoined -> True, AxesLabel -> {xLabel, yLabel}, 
         PlotStyle -> {Thickness[0.003], color[[i0]], Dashing[{}]}, opts, DisplayFunction -> Identity], 
        ListPlot[Transpose[{xv, vi}], PlotJoined -> True, AxesLabel -> {xLabel, yLabel}, 
         PlotStyle -> {Thickness[0.003], color[[i0]], Dashing[{0.02, 0.02}]}, opts, DisplayFunction -> Identity]}, 
      {i, 1, n}]; Show[g, DisplayFunction -> $DisplayFunction]]
VectorListPlot[v_List, xLabel_String, yLabel_String, opts___] := Module[{n, xv, yv, vt, nPts, style, g}, 
   n = Length[v[[1]]] - 1; vt = Transpose[v]; xv = vt[[1]]; nPts = Length[xv]; 
    style = {{Thickness[0.003], RGBColor[0, 0.5, 0], Dashing[{0.1, 0.02}]}, {Thickness[0.003], RGBColor[0, 0, 0]}, 
      {Thickness[0.003], RGBColor[0, 0, 1], Dashing[{0.02, 0.02}]}, {Thickness[0.003], RGBColor[1, 0, 0], 
       Dashing[{0.1, 0.02}]}, {Thickness[0.003], RGBColor[0, 0.5, 0], Dashing[{0.1, 0.02}]}}; 
    g = Table[i0 = Mod[i, 4] + 1; ListPlot[Transpose[{xv, vt[[i + 1]]}], PlotJoined -> True, 
        AxesLabel -> {xLabel, yLabel}, PlotStyle -> style[[i0]], opts, DisplayFunction -> Identity], {i, 1, n}]; 
    Show[g, DisplayFunction -> $DisplayFunction]]
ZeroContourPlot[v_List, xRange_List, yRange_List, opts___] := 
  Module[{range, gr}, range = {xRange, yRange}; gr = ListContourPlot[v, MeshRange -> range, Contours -> {0.}, 
      ContourShading -> False, ContourStyle -> RGBColor[1., 0., 0.], opts, DisplayFunction -> Identity]; 
    Show[gr, DisplayFunction -> $DisplayFunction]]
ComplexZeroContourPlot[v_List, xRange_List, yRange_List, opts___] := Module[{range, vreal, vimag, gr, gi}, 
   vreal = Re[v]; vimag = Im[v]; range = {xRange, yRange}; gr = ListContourPlot[vreal, MeshRange -> range, 
      Contours -> {0.}, ContourShading -> False, ContourStyle -> RGBColor[1., 0., 0.], opts, 
      DisplayFunction -> Identity]; gi = ListContourPlot[vimag, MeshRange -> range, Contours -> {0.}, 
      ContourShading -> False, ContourStyle -> RGBColor[0., 0., 1.], opts; DisplayFunction -> Identity]; 
    Show[gr, gi, DisplayFunction -> $DisplayFunction]]
rootSort[v_List] := Module[{t, tx, tr, t0, vout}, t = Transpose[v]; tx = First[t]; tr = Transpose[Rest[t]]; 
    t0 = continue[tr]; vout = Table[Prepend[t0[[i]], tx[[i]]], {i, 1, Length[tx]}]; vout]
continue[vin_List] := Module[{n, vout}, n = Length[vin]; vout = Array[cont, n]; vout[[1]] = vin[[1]]; 
    Do[vout[[i]] = cSort[vout[[i - 1]], vin[[i]]], {i, 2, n}]; vout]
cSort[v1_List, v2_List] := Module[{n, v, vtemp, ref, dt, i0}, n = Length[v1]; v = Array[cSort, n]; vtemp = v2; 
    Do[ref = v1[[i]]; dt = Table[Abs[ref - vtemp[[j]]], {j, 1, n}]; min = Sort[dt][[1]]; 
      i0 = Flatten[Position[dt, min]][[1]]; v[[i]] = v2[[i0]]; vtemp[[i0]] = Infinity, {i, 1, n}]; v]
End[]
EndPackage[]



